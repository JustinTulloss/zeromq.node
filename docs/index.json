[{"tags":[],"description":{"full":"<p>Module dependencies.</p>","summary":"<p>Module dependencies.</p>","body":""},"ignore":false,"code":"var EventEmitter = require('events').EventEmitter\n  , IOWatcher = process.binding('io_watcher').IOWatcher\n  , zmq = require('../binding');","ctx":{"type":"declaration","name":"EventEmitter","value":"require('events').EventEmitter","string":"EventEmitter"}},{"tags":[],"description":{"full":"<p>Expose bindings as the module.</p>","summary":"<p>Expose bindings as the module.</p>","body":""},"ignore":false,"code":"exports = module.exports = zmq;"},{"tags":[],"description":{"full":"<p>Map of socket types.</p>","summary":"<p>Map of socket types.</p>","body":""},"ignore":false,"code":"var types = exports.types = {\n    pub: zmq.ZMQ_PUB\n  , sub: zmq.ZMQ_SUB\n  , req: zmq.ZMQ_REQ\n  , xreq: zmq.ZMQ_XREQ\n  , rep: zmq.ZMQ_REP\n  , xrep: zmq.ZMQ_XREP\n  , push: zmq.ZMQ_PUSH\n  , pull: zmq.ZMQ_PULL\n  , dealer: zmq.ZMQ_DEALER\n  , router: zmq.ZMQ_ROUTER\n  , pair: zmq.ZMQ_PAIR\n};","ctx":{"type":"declaration","name":"types","value":"exports.types = {","string":"types"}},{"tags":[],"description":{"full":"<p>Map of socket options.</p>","summary":"<p>Map of socket options.</p>","body":""},"ignore":false,"code":"var opts = exports.options = {\n    _fd: zmq.ZMQ_FD\n  , _ioevents: zmq.ZMQ_EVENTS\n  , _receiveMore: zmq.ZMQ_RCVMORE\n  , _subscribe: zmq.ZMQ_SUBSCRIBE\n  , _unsubscribe: zmq.ZMQ_UNSUBSCRIBE\n  , affinity: zmq.ZMQ_AFFINITY\n  , backlog: zmq.ZMQ_BACKLOG\n  , hwm: zmq.ZMQ_HWM\n  , identity: zmq.ZMQ_IDENTITY\n  , linger: zmq.ZMQ_LINGER\n  , mcast_loop: zmq.ZMQ_MCAST_LOOP\n  , rate: zmq.ZMQ_RATE\n  , rcvbuf: zmq.ZMQ_RCVBUF\n  , reconnect_ivl: zmq.ZMQ_RECONNECT_IVL\n  , recovery_ivl: zmq.ZMQ_RECOVERY_IVL\n  , sndbuf: zmq.ZMQ_SNDBUF\n  , swap: zmq.ZMQ_SWAP\n};\n\n// Context management happens here. We lazily initialize a default context,\n// and use that everywhere. Also cleans up on exit.\nvar ctx;\nfunction defaultContext() {\n  if (ctx) return ctx;\n\n  var io_threads = 1;\n  if (process.env.ZMQ_IO_THREADS) {\n    io_threads = parseInt(process.env.ZMQ_IO_THREADS, 10);\n    if (!io_threads || io_threads < 1) {\n      console.warn('Invalid number in ZMQ_IO_THREADS, using 1 IO thread.');\n      io_threads = 1;\n    }\n  }\n\n  ctx = new zmq.Context(io_threads);\n  process.on('exit', function() {\n    // ctx.close();\n    ctx = null;\n  });\n\n  return ctx;\n};","ctx":{"type":"declaration","name":"opts","value":"exports.options = {","string":"opts"}},{"tags":[{"type":"constructor","string":""},{"type":"param","types":["String","Number"],"name":"type","description":""},{"type":"api","visibility":"public"}],"description":{"full":"<p>Create a new socket of the given <code>type</code>.</p>","summary":"<p>Create a new socket of the given <code>type</code>.</p>","body":""},"isPrivate":false,"ignore":false,"code":"function Socket(type) {\n  this.type = type;\n  this._zmq = new zmq.Socket(defaultContext(), types[type]);\n  this._outgoing = [];\n  this._watcher = new IOWatcher;\n  this._watcher.callback = this._flush.bind(this);\n  this._watcher.set(this._fd, true, false);\n  this._watcher.start();\n};","ctx":{"type":"function","name":"Socket","string":"Socket()"}},{"tags":[],"description":{"full":"<p>Inherit from <code>EventEmitter.prototype</code>.</p>","summary":"<p>Inherit from <code>EventEmitter.prototype</code>.</p>","body":""},"ignore":false,"code":"Socket.prototype.__proto__ = EventEmitter.prototype;","ctx":{"type":"property","constructor":"Socket","name":"__proto__","value":"EventEmitter.prototype","string":"Socket.prototype__proto__"}},{"tags":[{"type":"param","types":["String","Number"],"name":"opt","description":""},{"type":"param","types":["Mixed"],"name":"val","description":""},{"type":"return","types":["Socket"],"description":"for chaining"},{"type":"api","visibility":"public"}],"description":{"full":"<p>Set <code>opt</code> to <code>val</code>.</p>","summary":"<p>Set <code>opt</code> to <code>val</code>.</p>","body":""},"isPrivate":false,"ignore":false,"code":"Socket.prototype.setsockopt = function(opt, val){\n  this._zmq.setsockopt(opts[opt] || opt, val);\n  return this;\n};","ctx":{"type":"method","constructor":"Socket","name":"setsockopt","string":"Socket.prototype.setsockopt()"}},{"tags":[{"type":"param","types":["String","Number"],"name":"opt","description":""},{"type":"return","types":["Mixed"],"description":""},{"type":"api","visibility":"public"}],"description":{"full":"<p>Get socket <code>opt</code>.</p>","summary":"<p>Get socket <code>opt</code>.</p>","body":""},"isPrivate":false,"ignore":false,"code":"Socket.prototype.getsockopt = function(opt){\n  return this._zmq.getsockopt(opts[opt] || opt);\n};","ctx":{"type":"method","constructor":"Socket","name":"getsockopt","string":"Socket.prototype.getsockopt()"}},{"tags":[],"description":{"full":"<p>Socket opt accessors allowing <code>sock.backlog = val</code><br />instead of <code>sock.setsockopt('backlog', val)</code>.</p>","summary":"<p>Socket opt accessors allowing <code>sock.backlog = val</code><br />instead of <code>sock.setsockopt('backlog', val)</code>.</p>","body":""},"ignore":false,"code":"Object.keys(opts).forEach(function(name){\n  Socket.prototype.__defineGetter__(name, function() {\n    return this._zmq.getsockopt(opts[name]);\n  });\n\n  Socket.prototype.__defineSetter__(name, function(val) {\n    if ('string' == typeof val) val = new Buffer(val, 'utf8');\n    return this._zmq.setsockopt(opts[name], val);\n  });\n});"},{"tags":[{"type":"param","types":["String"],"name":"addr","description":""},{"type":"param","types":["Function"],"name":"cb","description":""},{"type":"return","types":["Socket"],"description":"for chaining"},{"type":"api","visibility":"public"}],"description":{"full":"<p>Async bind.</p>\n\n<p>Emits the \"bind\" event.</p>","summary":"<p>Async bind.</p>","body":"<p>Emits the \"bind\" event.</p>"},"isPrivate":false,"ignore":false,"code":"Socket.prototype.bind = function(addr, cb) {\n  var self = this;\n  self._watcher.stop();\n  self._zmq.bind(addr, function(err) {\n    self._watcher.start();\n    self.emit('bind');\n    cb && cb(err);\n  });\n  return this;\n};","ctx":{"type":"method","constructor":"Socket","name":"bind","string":"Socket.prototype.bind()"}},{"tags":[{"type":"param","types":["String"],"name":"addr","description":""},{"type":"return","types":["Socket"],"description":"for chaining"},{"type":"api","visibility":"public"}],"description":{"full":"<p>Sync bind.</p>","summary":"<p>Sync bind.</p>","body":""},"isPrivate":false,"ignore":false,"code":"Socket.prototype.bindSync = function(addr) {\n  this._watcher.stop();\n  try {\n    this._zmq.bindSync(addr);\n  } catch (e) {\n    this._watcher.start();\n    throw e;\n  }\n  this._watcher.start();\n  return this;\n};","ctx":{"type":"method","constructor":"Socket","name":"bindSync","string":"Socket.prototype.bindSync()"}},{"tags":[{"type":"param","types":["String"],"name":"addr","description":""},{"type":"return","types":["Socket"],"description":"for chaining"},{"type":"api","visibility":"public"}],"description":{"full":"<p>Connect to <code>addr</code>.</p>","summary":"<p>Connect to <code>addr</code>.</p>","body":""},"isPrivate":false,"ignore":false,"code":"Socket.prototype.connect = function(addr) {\n  this._zmq.connect(addr);\n  return this;\n};","ctx":{"type":"method","constructor":"Socket","name":"connect","string":"Socket.prototype.connect()"}},{"tags":[{"type":"param","types":["String"],"name":"filter","description":""},{"type":"return","types":["Socket"],"description":"for chaining"},{"type":"api","visibility":"public"}],"description":{"full":"<p>Subscribe with the given <code>filter</code>.</p>","summary":"<p>Subscribe with the given <code>filter</code>.</p>","body":""},"isPrivate":false,"ignore":false,"code":"Socket.prototype.subscribe = function(filter) {\n  this._subscribe = filter;\n  return this;\n};","ctx":{"type":"method","constructor":"Socket","name":"subscribe","string":"Socket.prototype.subscribe()"}},{"tags":[{"type":"param","types":["String"],"name":"filter","description":""},{"type":"return","types":["Socket"],"description":"for chaining"},{"type":"api","visibility":"public"}],"description":{"full":"<p>Unsubscribe with the given <code>filter</code>.</p>","summary":"<p>Unsubscribe with the given <code>filter</code>.</p>","body":""},"isPrivate":false,"ignore":false,"code":"Socket.prototype.unsubscribe = function(filter) {\n  this._unsubscribe = filter;\n  return this;\n};","ctx":{"type":"method","constructor":"Socket","name":"unsubscribe","string":"Socket.prototype.unsubscribe()"}},{"tags":[{"type":"param","types":["String","Buffer"],"name":"msg","description":""},{"type":"param","types":["Number"],"name":"flags","description":""},{"type":"return","types":["Socket"],"description":"for chaining"},{"type":"api","visibility":"public"}],"description":{"full":"<p>Send the given <code>msg</code>.</p>","summary":"<p>Send the given <code>msg</code>.</p>","body":""},"isPrivate":false,"ignore":false,"code":"Socket.prototype.send = function(msg, flags) {\n  // allow strings etc\n  if (!Buffer.isBuffer(msg)) {\n    msg = new Buffer(String(msg), 'utf8');\n  }\n\n  this._outgoing.push([msg, flags || 0]);\n  this._flush();\n\n  return this;\n};\n\n// The workhorse that does actual send and receive operations.\n// This helper is called from `send` above, and in response to\n// the watcher noticing the signaller fd is readable.\nSocket.prototype._flush = function() {\n  var args;\n\n  // Don't allow recursive flush invocation as it can lead to stack\n  // exhaustion and write starvation\n  if (this._flushing) return;\n\n  this._flushing = true;\n  try {\n    while (true) {\n      var emitArgs\n        , flags = this._ioevents;\n\n      if (!this._outgoing.length) {\n        flags &= ~zmq.ZMQ_POLLOUT;\n      }\n\n      if (!flags) break;\n    \n      if (flags & zmq.ZMQ_POLLIN) {\n          emitArgs = ['message'];\n\n          do {\n            emitArgs.push(new Buffer(this._zmq.recv()));\n          } while (this._receiveMore);\n\n          this.emit.apply(this, emitArgs);\n          if (this._zmq.state != zmq.STATE_READY) {\n            this._flushing = false;\n            return;\n          }\n      }\n\n      // We send as much as possible in one burst so that we don't\n      // starve sends if we receive more than one message for each\n      // one sent.\n      while (flags & zmq.ZMQ_POLLOUT && this._outgoing.length) {\n        args = this._outgoing.shift();\n        this._zmq.send(args[0], args[1]);\n        flags = this._ioevents;\n      }\n    }\n  } catch (e) {\n    this.emit('error', e);\n  }\n\n  this._flushing = false;\n};","ctx":{"type":"method","constructor":"Socket","name":"send","string":"Socket.prototype.send()"}},{"tags":[{"type":"return","types":["Socket"],"description":"for chaining"},{"type":"api","visibility":"public"}],"description":{"full":"<p>Close the socket.</p>","summary":"<p>Close the socket.</p>","body":""},"isPrivate":false,"ignore":false,"code":"Socket.prototype.close = function() {\n  this._watcher.stop();\n  this._watcher = null;\n  this._zmq.close();\n  return this;\n};","ctx":{"type":"method","constructor":"Socket","name":"close","string":"Socket.prototype.close()"}},{"tags":[{"type":"param","types":["String"],"name":"type","description":""},{"type":"param","types":["Object"],"name":"options","description":""},{"type":"return","types":["Socket"],"description":""},{"type":"api","visibility":"public"}],"description":{"full":"<p>Create a <code>type</code> socket with the given <code>options</code>.</p>","summary":"<p>Create a <code>type</code> socket with the given <code>options</code>.</p>","body":""},"isPrivate":false,"ignore":false,"code":"exports.socket = function(type, options) {\n  var sock = new Socket(type);\n  for (var key in options) sock[key] = options[key];\n  return sock;\n};","ctx":{"type":"method","receiver":"exports","name":"socket","string":"exports.socket()"}}]